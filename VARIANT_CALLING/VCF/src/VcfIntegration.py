'''
Created on 21 Jul 2017

@author: ernesto
'''
import os
import pdb
import subprocess

class VcfIntegration(object):
    '''
    Class to operate on a VCF file at the population level and perform
    different Genotype operations on it. For example, the estimation of
    the genotype likelihoods (with SNPTools), genotype calling (with Beagle)
    '''

    def __init__(self, vcf, reference=None, snptools_folder=None, beagle_folder=None, makeBGLCHUNKS_folder=None):
        '''
        Constructor

        Class variables
        ---------------
        vcf : str, Required
             Path to vcf file
        reference : str, Optional
             Path to fasta file containing the reference
        snptools_folder : str, Optional
                         Path to folder containing the snptools binaries (bamodel, poprob, etc.)
        beagle_folder : str, Optional
                        Path to folder containing Beagle's jar file
        makeBGLCHUNKS_folder : str, Optional
                               Path to folder containing makeBGLCHUNKS binary
                               (see https://mathgen.stats.ox.ac.uk/genetics_software/shapeit/shapeit.html#gettingstarted)
        '''

        if os.path.isfile(vcf) is False:
            raise Exception("File does not exist")

        self.vcf = vcf
        self.reference = reference
        self.snptools_folder = snptools_folder
        self.beagle_folder = beagle_folder
        self.makeBGLCHUNKS_folder = makeBGLCHUNKS_folder

    def run_snptools_bamodel(self, sample, bamfiles, outdir=None, verbose=False):
        '''
        Method that wraps SNPTools' bamodel on a VCF containing only Biallelic SNPs
        See https://www.hgsc.bcm.edu/software/snptools

        Parameters
        ----------
        sample: str, required
              sample to analyze
        bamfiles : str, required
              file containing the BAM path/s (one per line) for sample
        outdir : str, optional
              outdir for output files
        verbose : bool, optional
              if true, then print the command line used for running SNPTools

        Returns
        -------
        Returns a *.raw file
        '''
        # parse bamfiles
        bamf = open(bamfiles, 'r')
        bams= list(set(bamf.read().splitlines()))
        # remove empty elements
        bams = list(filter(None, bams))

        program_folder = ""
        if self.snptools_folder:
            program_folder += self.snptools_folder + "/"

        outfile=""
        if outdir is not None:
            outfile="{0}/{1}".format(outdir,sample)
        else:
            outfile="{0}".format(sample)

        bam_str=" ".join(list(filter(lambda x:sample in x, bams)))

        command = "{0}/bamodel {1} {2} {3}".format(program_folder,
                                                   outfile, self.vcf,
                                                   bam_str)

        if verbose==True:
            print("Command used was: %s" % command)

        try:
            subprocess.check_output(command, shell=True)
        except subprocess.CalledProcessError as exc:
            print("Something went wrong while running SNPTools bamodel\n"
                  "Command used was: %s" % command)
            raise Exception(exc.output)

        if os.path.isfile(outfile+".raw") == False:
            raise Exception("Something went wrong while running SNPTools bamodel\n"
                            "{0} could not be created".format(outfile))

        return outfile+".raw"

    def run_snptools_poprob(self, outprefix, rawlist, outdir=None, verbose=False): 
        '''
        Method that wraps SNPTools' poprob on a VCF containing only Biallelic SNPs
        See https://www.hgsc.bcm.edu/software/snptools

        Parameters
        ----------
        outprefix: str, required
              prefix for *.prob file
        rawlist: str, required
              file containing the paths to the *.raw files generated by
              'run_snptools_bamodel'
        outdir : str, optional
               outdir for output files
        verbose : bool, optional
                  if true, then print the command line used for running SNPTools

        Returns
        -------
        Returns a *.prob file
        '''

        program_folder = ""
        if self.snptools_folder:
            program_folder += self.snptools_folder + "/"

        outfile=""
        if outdir is not None:
            outfile="{0}/{1}.prob".format(outdir,outprefix)
        else:
            outfile="{0}.prob".format(outprefix)

        command = "{0}/poprob {1} {2} {3}".format(program_folder,
                                                  self.vcf,
                                                  rawlist,
                                                  outfile)
        
        if verbose==True:
            print("Command used was: %s" % command)
        
        try:
            subprocess.check_output(command, shell=True)
        except subprocess.CalledProcessError as exc:
            print("Something went wrong while running SNPTools poprob\n"
                  "Command used was: %s" % command)
            raise Exception(exc.output)

        if os.path.isfile(outfile) == False:
            raise Exception("Something went wrong while running SNPTools poprob\n"
                            "{0} could not be created".format(outfile))

        return outfile


    def run_snptools_prob2vcf(self, probf, outprefix, chro, outdir=None, verbose=False):
        '''
        Method that wraps SNPTools' prob2vcf on a VCF containing only Biallelic SNPs
        See https://www.hgsc.bcm.edu/software/snptools

        Parameters
        ----------
        probf: str, required
              *.prob file generated by 'run_snptools_poprob'
        outprefix: str, required
              Prefix used for output file
        chro: str, required
              chromosome for which the vcf will be generated
        outdir : str, optional
               outdir for output files
        verbose : bool, optional
                  if true, then print the command line used for running SNPTools

        Returns
        -------
        Compressed VCF file with the population genotype likelihoods

        '''

        program_folder = ""
        if self.snptools_folder:
            program_folder += self.snptools_folder + "/"

        outfile=""
        if outdir is not None:
            outfile="{0}/{1}.vcf.gz".format(outdir, outprefix)
        else:
            outfile="{0}.vcf.gz".format(outprefix)

        command = "{0}/prob2vcf {1} {2} {3}".format(program_folder,
                                                    probf,
                                                    outfile,
                                                    chro)

        if verbose==True:
            print("Command used was: %s" % command)

        try:
            subprocess.check_output(command, shell=True)
        except subprocess.CalledProcessError as exc:
            print("Something went wrong while running SNPTools prob2vcf\n"
                  "Command used was: %s" % command)
            raise Exception(exc.output)

        if os.path.isfile(outfile) == False:
            raise Exception("Something went wrong while running SNPTools prob2vcf\n"
                            "{0} could not be created".format(outfile))

        return outfile

    def run_beagle(self, outprefix, outdir=None, region=None, verbose=False, **kwargs):
        '''
        Method that wraps Beagle (see https://faculty.washington.edu/browning/beagle/beagle.html)
        and will be used to call genotypes on a VCF file containing GT likelihoods

        Parameters
        ----------
        outprefix: str, required
              Prefix used for output file
        outdir : str, optional
                 outdir for output files
        region : str, optional
                 chr or chr interval that will be analyzed. i.e. chr20 or chr20:10000000-11000000
        verbose : bool, optional
                  if true, then print the command line used for running Beagle
        window: int, optional
                number of markers to include in each sliding
                window. Default: 50000
        overlap: int, optional
                 specifies the number of markers of overlap between sliding
                 windows. Default: 3000
        niterations: unt, optional
                     specifies the number of phasing iterations. Default:
                     niterations=5
        nthreads : int, optional
                   number of threads. If not specified then the nthreads parameter 
                   will be set equal to the number of CPU cores on the host machine

        Returns
        -------
        Compressed VCF file with the genotype calls
        '''

        program_folder = ""
        if self.beagle_folder:
            program_folder += self.beagle_folder + "/"

        outfile=""
        if outdir is not None:
            outfile="{0}/{1}.".format(outdir, outprefix)
        else:
            outfile="{0}.".format(outprefix)

        if region is not None:
            outfile+="{0}.".format(region)

        outfile+="beagle"

        command = "java -jar {0}/beagle.08Jun17.d8b.jar gl={1} out={2}".format(program_folder,
                                                                               self.vcf,
                                                                               outfile)

        for k,v in kwargs.items():
            command += " {0}={1}".format(k,v)
            
        if verbose==True:
            print("Command used was: %s" % command)

        try:
            subprocess.check_output(command, shell=True)
        except subprocess.CalledProcessError as exc:
            print("Something went wrong while running Beagle\n"
                  "Command used was: %s" % command)
            raise Exception(exc.output)

        return outfile+".vcf.gz"

    def make_beagle_chunks(self,window,overlap,outfile,correct=False,chrname=None,verbose=False):
        '''
        Method to define chromosome chunks for Beagle
        see https://mathgen.stats.ox.ac.uk/genetics_software/shapeit/shapeit.html#gettingstarted

        Parameters
        ----------
        window: int, required
                The chunk size (--window) in number of variant sites
        overlap: int, required
                 The overlap size (--overlap) in number of variant sites
        outfile: str, required
                 Name of output file. i.e. 'chunk.coordinates'
        correct: bool, optional
                 If True, then correct the output file in order to have UCSC-style chro names
        chrname: str, optional.
                 If 'correct'=True then pass the UCSC-style chro names that will be used
        verbose : bool, optional
                  if true, then print the command line used for running this tool.Default=False

        Returns
        -------
        Path to file with the coordinates of the chunk

        '''

        program_folder = ""
        if self.makeBGLCHUNKS_folder:
            program_folder += self.makeBGLCHUNKS_folder + "/"

        command = "{0}/makeBGLCHUNKS --vcf {1} --window {2} --overlap {3} --output {4}".format(program_folder,
                                                                                                self.vcf,
                                                                                                window,
                                                                                                overlap,
                                                                                                outfile)
        
        if verbose==True:
            print("Command used was: %s" % command)

        try:
            subprocess.check_output(command, shell=True)
            if os.path.isfile(outfile) == False:
                print("Error. Something went wrong while running command: {0}".format(command))
                raise Exception("File cound not be created")
        except subprocess.CalledProcessError as exc:
            print("Something went wrong while running makeBGLCHUNKS\n"
                  "Command used was: %s" % command)
            raise Exception(exc.output)
        
        '''
        when the VCF file used as input contains UCSC-style chro names, then makeBGLCHUNKS will generate
        a first column with '0s'. This needs to be corrected
        '''
        if correct is True:
            if chrname is None:
                 raise Exception("Please set the 'chrname' arg")
            newoutfile=outfile+'.ucsc.corr'
            fw=open(newoutfile,'w');

            with open(outfile) as fr:
                for line in fr:
                    line=line.rstrip('\n')
                    bits=line.split("\t")
                    bits[0]=chrname
                    nline='\t'.join(bits)
                    fw.write(nline+"\n")
            fw.close()
            outfile=newoutfile

        return outfile

    def prepare_Gen_From_Beagle4(self,prefix_in,output,threshold=0.995):
        '''
        Method that uses prepareGenFromBeagle4 in order to convert the different Beagle chunks
        generated by 'self.make_beagle_chunks' into a single concatenated output that can be used 
        with SHAPEIT.
        see https://mathgen.stats.ox.ac.uk/genetics_software/shapeit/shapeit.html#gettingstarted

        Parameters
        ----------
        prefix_in: str, required
                   prefix used in the output of the different Beagle chunks after running  method 'self.make_beagle_chunks'
        output: str, required
                prefix for output files
        threshold: float, optional
                   Threshold meaning that all genotypes with a posterior above 0.995 are directly fixed and will only need phasing in the SHAPEIT step.
                   Default: 0.995
        
        '''

        program_folder = ""
        if self.prepareGenFromBeagle4_folder:
            program_folder += self.prepareGenFromBeagle4_folder + "/"

        command = "{0}/prepareGenFromBeagle4 --likelihoods {1} --posteriors {2} --threshold {3} --output input.shapeit.22".format(program_folder,
                                                                                                                                  self.vcf,
                                                                                                                                  window,
                                                                                                                                  threshold,
                                                                                                                                  outfile)
